<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Relational Landscapes</title>
		<meta charset="utf-8">
		<style>body { margin: 0; }</style>
	</head>
	<body>
		<script type="module">

			import * as THREE from './three/build/three.module.js';

			import { OrbitControls } from './three/examples/jsm/controls/OrbitControls.js';
			import { PCDLoader } from './three/examples/jsm/loaders/PCDLoader.js';
            import { EffectComposer } from './three/examples/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from './three/examples/jsm/postprocessing/RenderPass.js';
			import { UnrealBloomPass } from './three/examples/jsm/postprocessing/UnrealBloomPass.js';

			let camera, scene, renderer, composer, pointcloud;
            let d=[];
            const c1=new THREE.Color(0.62,0.125,0.06);
            const c2=new THREE.Color(0.125,0.6,0.36);

            const params = {
				exposure: 0.8,
				bloomStrength: 0.3,
				bloomThreshold: 0,
				bloomRadius: 0
			};

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();


            const sphereGeometry = new THREE.SphereGeometry( 2, 32, 32 );
			const sphereMaterial = new THREE.MeshBasicMaterial( { color: c1, opacity: 0.5, transparent: true } );
			const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
            
            let p=[new THREE.Vector3(0,0,0), new THREE.Vector3(-28,-26,66), new THREE.Vector3(2,-40,-67), new THREE.Vector3(18,7,59)];

			init();
			render();

			function init() {

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 0.01, 1000 );
				camera.position.set( 130, 0, 250 );
				scene.add( camera );

                const renderScene = new RenderPass( scene, camera );

				const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
				bloomPass.threshold = params.bloomThreshold;
				bloomPass.strength = params.bloomStrength;
				bloomPass.radius = params.bloomRadius;

				composer = new EffectComposer( renderer );
				composer.addPass( renderScene );
				composer.addPass( bloomPass );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop


				const loader = new PCDLoader();
				loader.load( './pointcloud.pcd', function ( points ) {

					points.geometry.center();
                    points.material.size=1;
					scene.add( points );
                    pointcloud=points;
					render();

				} );
                scene.add(sphere);
				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
                composer.setSize( window.innerWidth, window.innerHeight );
                render();

			}

            function onMouseMove( event ) {
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                render();
            }

			function render() {
                if(pointcloud != null){
                    raycaster.setFromCamera( mouse, camera );
                    let intersects = raycaster.intersectObject(pointcloud);
                    let geometry = pointcloud.geometry;
                    let attributes = geometry.attributes;
                    if ( intersects.length > 0 ) {
                        p[0] = new THREE.Vector3(intersects[0].point.x,intersects[0].point.y,intersects[0].point.z);
                        d=[p[0].distanceTo(p[1]),p[0].distanceTo(p[2]),p[0].distanceTo(p[3])];
                        sphere.material.color.lerpColors(c2,c1,clamp(mapRange(Math.min(...d),0,50,0,1),0,1));
                        sphere.material.opacity=clamp(mapRange(Math.min(...d),0,50,0.8,0.4),0.4,0.8);
                        if(Math.min(...d)<2){
                            sphere.scale.set(1.25,1.25,1.25);
                        } else {
                            sphere.scale.set(0.8,0.8,0.8);
                        }
                        sphere.position.set(intersects[0].point.x,intersects[0].point.y,intersects[0].point.z);
                        attributes.color.array[intersects[0].index*3] = 1.0;
                        attributes.color.array[intersects[0].index*3+1] = 0.0;
                        attributes.color.array[intersects[0].index*3+2] = 0.0;
                        attributes.color.needsUpdate = true;
                    }
                }

                composer.render();
			}
            
            function mapRange (value, a, b, c, d) {
                value = (value - a) / (b - a);
                return c + value * (d - c);
            }

            function clamp(val, min, max) {
                return val > max ? max : val < min ? min : val;
            }
            window.addEventListener( 'mousemove', onMouseMove, false );

		</script>
	</body>
</html>