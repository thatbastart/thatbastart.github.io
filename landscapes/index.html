<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Relational Landscapes</title>
		<meta charset="utf-8">
		<style>body { margin: 0; }</style>
	</head>
	<body>
        <h1 id="title" style="color: #ffffff; position: absolute; left:25px; top:0px; text-shadow: 0 0 5px #000000"></h1>
        <div id="main" style="background-color:#ffffff; border-radius: 25px; position: absolute; left:50vw; top:5vh; width: 47vw; height: 90vh; padding: 10px; box-shadow: 0 0 5px #000000; display: none;"><h1 id="main-title"></h1></div>
		<script type="module">

			import * as THREE from './three/build/three.module.js';

			import { OrbitControls } from './three/examples/jsm/controls/OrbitControls.js';
			import { PCDLoader } from './three/examples/jsm/loaders/PCDLoader.js';
            import { EffectComposer } from './three/examples/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from './three/examples/jsm/postprocessing/RenderPass.js';
			import { UnrealBloomPass } from './three/examples/jsm/postprocessing/UnrealBloomPass.js';

			let camera, scene, renderer, composer, pointcloud;
            let d=[];
            const c1=new THREE.Color(0.62,0.125,0.06);
            const c2=new THREE.Color(0.125,0.6,0.36);
            const c3=new THREE.Color(0,0,0);
            let overMain=false;
            let drag=false;
            const camQuats = new THREE.Vector4();

            const params = {
				exposure: 0.8,
				bloomStrength: 0.3,
				bloomThreshold: 0,
				bloomRadius: 0
			};

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();


            const sphereGeometry = new THREE.SphereGeometry( 2, 32, 32 );
			const sphereMaterial = new THREE.MeshBasicMaterial( { color: c1, opacity: 0.5, transparent: true } );
            const sphTargetMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 0.85, transparent: true } );
			const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
            const sphTarget = new THREE.Mesh( sphereGeometry, sphTargetMaterial );
            
            let p=[new THREE.Vector3(0,0,0), new THREE.Vector3(-28,-26,66), new THREE.Vector3(2,-40,-67), new THREE.Vector3(18,7,59)];

			init();
			render();

			function init() {

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 0.01, 1000 );
				camera.position.set( 130, 0, 250 );
				scene.add( camera );

                const renderScene = new RenderPass( scene, camera );

				const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
				bloomPass.threshold = params.bloomThreshold;
				bloomPass.strength = params.bloomStrength;
				bloomPass.radius = params.bloomRadius;

				composer = new EffectComposer( renderer );
				composer.addPass( renderScene );
				composer.addPass( bloomPass );

				const controls = new OrbitControls( camera, renderer.domElement );
                controls.dampingFactor=0.01;
				controls.addEventListener( 'change', render );
                controls.addEventListener('start', (e) => {
                    camQuats.x=camera.quaternion.x;
                    camQuats.y=camera.quaternion.y;
                    camQuats.z=camera.quaternion.z;
                    camQuats.w=camera.quaternion.w;
                });

                controls.addEventListener('end', (e) => {
                    if (camQuats.x==camera.quaternion.x && camQuats.y==camera.quaternion.y && camQuats.z==camera.quaternion.z && camQuats.w==camera.quaternion.w){
                        drag=false;
                    } else {
                        drag=true;
                    }
                });


				const loader = new PCDLoader();
				loader.load( './pointcloud.pcd', function ( points ) {

					points.geometry.center();
                    points.material.size=1;
					scene.add( points );
                    pointcloud=points;
					render();

				} );
                scene.add(sphere);
                scene.add(sphTarget);
                sphTarget.visible=false;
				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
                composer.setSize( window.innerWidth, window.innerHeight );
                render();

			}

            function onMouseMove( event ) {
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                render();
            }

            function onPointerUp( event ) {
                if(drag==false && event.button!=0){
                    drag=true;
                }
                if(Math.min(...d)<2){
                    let n=d.indexOf(Math.min(...d));
                    document.getElementById("main").style.display="inline";
                    if (n==0){
                        document.getElementById("main-title").innerHTML="Point One";
                    } else if (n==1){
                        document.getElementById("main-title").innerHTML="Point Two";
                    } else if (n==2){ 
                        document.getElementById("main-title").innerHTML="Point Three";
                    }
                } else {
                    if(overMain==false && drag==false){
                        document.getElementById("main").style.display="none";
                    }
                }
            }

			function render() {
                if(pointcloud != null){
                    raycaster.setFromCamera( mouse, camera );
                    let intersects = raycaster.intersectObject(pointcloud);
                    let geometry = pointcloud.geometry;
                    let attributes = geometry.attributes;
                    if ( intersects.length > 0 ) {
                        p[0] = new THREE.Vector3(intersects[0].point.x,intersects[0].point.y,intersects[0].point.z);
                        d=[p[0].distanceTo(p[1]),p[0].distanceTo(p[2]),p[0].distanceTo(p[3])];
                        c3.lerpColors(c2,c1,clamp(mapRange(Math.min(...d),0,50,0,1),0,1));
                        sphere.material.color.copy(c3);
                        sphere.material.opacity=clamp(mapRange(Math.min(...d),0,50,0.8,0.4),0.4,0.8);
                        if(Math.min(...d)<2){
                            sphere.scale.set(1.25,1.25,1.25);
                            let n=d.indexOf(Math.min(...d));
                            sphTarget.visible=true;
                            sphTarget.position.set(p[n+1].x,p[n+1].y,p[n+1].z);
                            if (n==0){
                                document.getElementById("title").innerHTML="Point One";
                            } else if (n==1){
                                document.getElementById("title").innerHTML="Point Two";
                            } else if (n==2){ 
                                document.getElementById("title").innerHTML="Point Three";
                            }
                        } else {
                            sphTarget.visible=false;
                            sphere.scale.set(0.8,0.8,0.8);
                            document.getElementById("title").innerHTML="";
                        }
                        sphere.position.set(intersects[0].point.x,intersects[0].point.y,intersects[0].point.z);
                        attributes.color.array[intersects[0].index*3] = 1.0;
                        attributes.color.array[intersects[0].index*3+1] = 0.0;
                        attributes.color.array[intersects[0].index*3+2] = 0.0;
                        attributes.color.needsUpdate = true;
                    }
                }

                composer.render();
			}
            
            function mapRange (value, a, b, c, d) {
                value = (value - a) / (b - a);
                return c + value * (d - c);
            }

            function clamp(val, min, max) {
                return val > max ? max : val < min ? min : val;
            }

            window.addEventListener( "mousemove", onMouseMove, false );
            window.addEventListener( "pointerup", onPointerUp, false );
            document.getElementById("main").addEventListener("mouseenter", function(){ overMain=true; }, false);
            document.getElementById("main").addEventListener("mouseleave", function(){ overMain=false; }, false);

		</script>
	</body>
</html>